import { useState, useEffect, useCallback } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useAuthStore, selectUser } from '@/hooks/auth/useAuthStore';
import { toast } from 'sonner';

// Interface definitions for dashboard data
export interface CategoryProgress {
  id: string;
  name: string;
  description?: string;
  assignment: string;
  totalColumns: number;
  filledColumns: number;
  requiredColumns: number;
  filledRequiredColumns: number;
  progress: number;
  status: 'not-started' | 'in-progress' | 'completed' | 'pending' | 'approved';
  lastUpdated?: Date;
  deadline?: Date;
}

export interface ColumnStatus {
  id: string;
  name: string;
  categoryId: string;
  categoryName: string;
  type: string;
  isRequired: boolean;
  isFilled: boolean;
  value?: any;
  status: 'draft' | 'pending' | 'approved' | 'rejected';
  lastUpdated?: Date;
  rejectionReason?: string;
}

export interface Activity {
  id: string;
  type: 'data_entry' | 'approval' | 'rejection' | 'edit';
  categoryName: string;
  columnName: string;
  timestamp: Date;
  status: string;
  description: string;
}

export interface PendingApproval {
  id: string;
  categoryId: string;
  categoryName: string;
  columnId: string;
  columnName: string;
  value: any;
  submittedAt: Date;
}

export interface SchoolDashboardData {
  // Overview stats
  totalCategories: number;
  completedCategories: number;
  totalColumns: number;
  filledColumns: number;
  overallProgress: number;
  
  // Category details
  categoryProgress: CategoryProgress[];
  
  // Column details
  columnStatuses: ColumnStatus[];
  
  // Recent activity
  recentActivities: Activity[];
  
  // Pending approvals
  pendingApprovals: PendingApproval[];
}

interface UseSchoolDashboardDataOptions {
  autoRefresh?: boolean;
  refreshInterval?: number; // in milliseconds
}

export const useSchoolDashboardData = (options: UseSchoolDashboardDataOptions = {}) => {
  const { autoRefresh = false, refreshInterval = 30000 } = options;
  const user = useAuthStore(selectUser);
  const schoolId = user?.school_id || user?.schoolId;

  // State management
  const [data, setData] = useState<SchoolDashboardData>({
    totalCategories: 0,
    completedCategories: 0,
    totalColumns: 0,
    filledColumns: 0,
    overallProgress: 0,
    categoryProgress: [],
    columnStatuses: [],
    recentActivities: [],
    pendingApprovals: []
  });
  
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Fetch categories and their columns for school admin
  const fetchCategories = useCallback(async () => {
    if (!schoolId) return [];

    try {
      const { data: categories, error } = await supabase
        .from('categories')
        .select(`
          *,
          columns(*)
        `)
        .eq('assignment', 'all')
        .eq('status', 'active')
        .order('name');

      if (error) throw error;

      return categories || [];
    } catch (err: any) {
      console.error('Error fetching categories:', err);
      throw new Error('Kateqoriyalar yüklənərkən xəta baş verdi: ' + err.message);
    }
  }, [schoolId]);

  // Fetch data entries for the school
  const fetchDataEntries = useCallback(async () => {
    if (!schoolId) return [];

    try {
      const { data: entries, error } = await supabase
        .from('data_entries')
        .select(`
          *,
          columns!inner(
            *,
            categories!inner(*)
          )
        `)
        .eq('school_id', schoolId);

      if (error) throw error;

      return entries || [];
    } catch (err: any) {
      console.error('Error fetching data entries:', err);
      throw new Error('Məlumat girişləri yüklənərkən xəta baş verdi: ' + err.message);
    }
  }, [schoolId]);

  // Calculate category progress
  const calculateCategoryProgress = useCallback((categories: any[], dataEntries: any[]): CategoryProgress[] => {
    return categories.map(category => {
      const categoryColumns = category.columns || [];
      const totalColumns = categoryColumns.length;
      const requiredColumns = categoryColumns.filter((col: any) => col.is_required).length;

      // Get entries for this category
      const categoryEntries = dataEntries.filter(entry => 
        entry.columns?.categories?.id === category.id
      );

      const filledColumns = categoryColumns.filter((col: any) => 
        categoryEntries.some(entry => entry.column_id === col.id && 
          entry.value !== null && entry.value !== undefined && String(entry.value).trim() !== '')
      ).length;

      const filledRequiredColumns = categoryColumns.filter((col: any) => 
        col.is_required && categoryEntries.some(entry => 
          entry.column_id === col.id && 
          entry.value !== null && entry.value !== undefined && String(entry.value).trim() !== '')
      ).length;

      const progress = totalColumns > 0 ? Math.round((filledColumns / totalColumns) * 100) : 0;

      // Determine status
      let status: CategoryProgress['status'] = 'not-started';
      if (filledColumns === 0) {
        status = 'not-started';
      } else if (filledRequiredColumns === requiredColumns && filledColumns === totalColumns) {
        // Check if all entries are approved
        const allApproved = categoryEntries.every(entry => entry.status === 'approved');
        const hasPending = categoryEntries.some(entry => entry.status === 'pending');
        
        if (allApproved) {
          status = 'approved';
        } else if (hasPending) {
          status = 'pending';
        } else {
          status = 'completed';
        }
      } else {
        status = 'in-progress';
      }

      // Get last updated date
      const lastUpdated = categoryEntries.length > 0 
        ? new Date(Math.max(...categoryEntries.map(entry => new Date(entry.updated_at).getTime())))
        : undefined;

      return {
        id: category.id,
        name: category.name,
        description: category.description,
        assignment: category.assignment,
        totalColumns,
        filledColumns,
        requiredColumns,
        filledRequiredColumns,
        progress,
        status,
        lastUpdated,
        deadline: category.deadline ? new Date(category.deadline) : undefined
      };
    });
  }, []);

  // Calculate column statuses
  const calculateColumnStatuses = useCallback((categories: any[], dataEntries: any[]): ColumnStatus[] => {
    const columnStatuses: ColumnStatus[] = [];

    categories.forEach(category => {
      const categoryColumns = category.columns || [];
      
      categoryColumns.forEach((column: any) => {
        const entry = dataEntries.find(e => e.column_id === column.id);
        
        const isFilled = entry && entry.value !== null && entry.value !== undefined && String(entry.value).trim() !== '';
        
        columnStatuses.push({
          id: column.id,
          name: column.name,
          categoryId: category.id,
          categoryName: category.name,
          type: column.type,
          isRequired: column.is_required || false,
          isFilled,
          value: entry?.value,
          status: entry?.status || 'draft',
          lastUpdated: entry ? new Date(entry.updated_at) : undefined,
          rejectionReason: entry?.rejection_reason
        });
      });
    });

    return columnStatuses;
  }, []);

  // Generate recent activities
  const generateRecentActivities = useCallback((dataEntries: any[]): Activity[] => {
    return dataEntries
      .filter(entry => entry.columns?.categories)
      .map(entry => ({
        id: entry.id,
        type: 'data_entry' as const,
        categoryName: entry.columns.categories.name,
        columnName: entry.columns.name,
        timestamp: new Date(entry.updated_at),
        status: entry.status,
        description: `${entry.columns.categories.name} - ${entry.columns.name} sahəsi ${entry.status === 'approved' ? 'təsdiqləndi' : entry.status === 'pending' ? 'təsdiq gözləyir' : 'yeniləndi'}`
      }))
      .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())
      .slice(0, 10); // Latest 10 activities
  }, []);

  // Generate pending approvals
  const generatePendingApprovals = useCallback((dataEntries: any[]): PendingApproval[] => {
    return dataEntries
      .filter(entry => entry.status === 'pending' && entry.columns?.categories)
      .map(entry => ({
        id: entry.id,
        categoryId: entry.columns.categories.id,
        categoryName: entry.columns.categories.name,
        columnId: entry.column_id,
        columnName: entry.columns.name,
        value: entry.value,
        submittedAt: new Date(entry.updated_at)
      }))
      .sort((a, b) => b.submittedAt.getTime() - a.submittedAt.getTime());
  }, []);

  // Main data fetching function
  const fetchDashboardData = useCallback(async () => {
    if (!schoolId) {
      setError('Məktəb ID-si tapılmadı');
      setLoading(false);
      return;
    }

    try {
      setLoading(true);
      setError(null);

      console.log('Fetching dashboard data for school:', schoolId);

      // Fetch categories and data entries in parallel
      const [categories, dataEntries] = await Promise.all([
        fetchCategories(),
        fetchDataEntries()
      ]);

      console.log('Fetched categories:', categories.length);
      console.log('Fetched data entries:', dataEntries.length);

      // Calculate progress and statuses
      const categoryProgress = calculateCategoryProgress(categories, dataEntries);
      const columnStatuses = calculateColumnStatuses(categories, dataEntries);
      const recentActivities = generateRecentActivities(dataEntries);
      const pendingApprovals = generatePendingApprovals(dataEntries);

      // Calculate overall stats
      const totalCategories = categories.length;
      const completedCategories = categoryProgress.filter(cat => cat.status === 'completed' || cat.status === 'approved').length;
      const totalColumns = columnStatuses.length;
      const filledColumns = columnStatuses.filter(col => col.isFilled).length;
      const overallProgress = totalColumns > 0 ? Math.round((filledColumns / totalColumns) * 100) : 0;

      console.log('Calculated stats:', {
        totalCategories,
        completedCategories,
        totalColumns,
        filledColumns,
        overallProgress
      });

      setData({
        totalCategories,
        completedCategories,
        totalColumns,
        filledColumns,
        overallProgress,
        categoryProgress,
        columnStatuses,
        recentActivities,
        pendingApprovals
      });

    } catch (err: any) {
      console.error('Error fetching dashboard data:', err);
      setError(err.message);
      toast.error('Dashboard məlumatları yüklənərkən xəta baş verdi');
    } finally {
      setLoading(false);
    }
  }, [
    schoolId,
    fetchCategories,
    fetchDataEntries,
    calculateCategoryProgress,
    calculateColumnStatuses,
    generateRecentActivities,
    generatePendingApprovals
  ]);

  // Auto-refresh effect
  useEffect(() => {
    fetchDashboardData();

    if (autoRefresh && refreshInterval > 0) {
      const interval = setInterval(fetchDashboardData, refreshInterval);
      return () => clearInterval(interval);
    }
  }, [fetchDashboardData, autoRefresh, refreshInterval]);

  // Realtime subscription for data changes
  useEffect(() => {
    if (!schoolId) return;

    const subscription = supabase
      .channel('dashboard_updates')
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'data_entries',
        filter: `school_id=eq.${schoolId}`
      }, () => {
        console.log('Data entry changed, refreshing dashboard...');
        fetchDashboardData();
      })
      .subscribe();

    return () => {
      subscription.unsubscribe();
    };
  }, [schoolId, fetchDashboardData]);

  // Manual refresh function
  const refresh = useCallback(() => {
    fetchDashboardData();
  }, [fetchDashboardData]);

  // Get category by ID
  const getCategoryById = useCallback((categoryId: string) => {
    return data.categoryProgress.find(cat => cat.id === categoryId);
  }, [data.categoryProgress]);

  // Get columns for category
  const getColumnsForCategory = useCallback((categoryId: string) => {
    return data.columnStatuses.filter(col => col.categoryId === categoryId);
  }, [data.columnStatuses]);

  return {
    data,
    loading,
    error,
    refresh,
    getCategoryById,
    getColumnsForCategory,
    
    // Utility functions
    isReady: !loading && !error,
    hasData: data.totalCategories > 0,
    isEmpty: data.totalCategories === 0 && !loading
  };
};