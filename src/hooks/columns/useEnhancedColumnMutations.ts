import { useMutation, useQueryClient } from '@tanstack/react-query';\nimport { supabase } from '@/lib/supabase';\nimport { Column } from '@/types/column';\nimport { toast } from 'sonner';\n\ninterface EnhancedDeleteOptions {\n  hardDelete?: boolean;\n  exportData?: boolean;\n  confirmation: string;\n}\n\ninterface DeleteResult {\n  success: boolean;\n  deletionType: 'soft' | 'permanent';\n  deletedRecords: {\n    dataEntries: number;\n    sectorEntries: number;\n  };\n  exportUrl?: string;\n  restorationDeadline?: string;\n}\n\nexport const useEnhancedColumnMutations = () => {\n  const queryClient = useQueryClient();\n\n  // Enhanced delete mutation\n  const enhancedDeleteColumn = useMutation({\n    mutationFn: async ({ \n      columnId, \n      options \n    }: { \n      columnId: string; \n      options: EnhancedDeleteOptions \n    }): Promise<DeleteResult> => {\n      console.log('üóëÔ∏è Enhanced delete column:', { columnId, options });\n      \n      // Call the enhanced delete edge function\n      const { data, error } = await supabase.functions.invoke('enhanced-delete-column', {\n        body: {\n          columnId,\n          hardDelete: options.hardDelete || false,\n          exportData: options.exportData || false,\n          confirmation: options.confirmation\n        }\n      });\n\n      if (error) {\n        console.error('‚ùå Enhanced delete error:', error);\n        throw new Error(error.message || 'Failed to delete column');\n      }\n\n      if (!data.success) {\n        throw new Error(data.error || 'Failed to delete column');\n      }\n\n      console.log('‚úÖ Enhanced delete successful:', data);\n      return data;\n    },\n    onSuccess: (result, variables) => {\n      // Invalidate relevant queries\n      queryClient.invalidateQueries({ queryKey: ['columns'] });\n      queryClient.invalidateQueries({ queryKey: ['data_entries'] });\n      queryClient.invalidateQueries({ queryKey: ['sector_data_entries'] });\n      \n      // Show appropriate success message\n      const deletedCount = result.deletedRecords.dataEntries + result.deletedRecords.sectorEntries;\n      \n      if (result.deletionType === 'permanent') {\n        toast.success(\n          `S√ºtun tamamil…ô silindi${deletedCount > 0 ? ` (${deletedCount} m…ôlumat da silindi)` : ''}`,\n          {\n            description: 'Bu …ôm…ôliyyat geri qaytarƒ±la bilm…ôz.',\n            duration: 5000\n          }\n        );\n      } else {\n        toast.success(\n          `S√ºtun silindi${deletedCount > 0 ? ` (${deletedCount} m…ôlumat da silindi)` : ''}`,\n          {\n            description: result.restorationDeadline \n              ? `B…ôrpa m√ºdd…ôti: ${new Date(result.restorationDeadline).toLocaleDateString()}`\n              : '30 g√ºn …ôrzind…ô b…ôrpa edil…ô bil…ôr.',\n            duration: 5000\n          }\n        );\n      }\n      \n      // Show export notification if applicable\n      if (result.exportUrl) {\n        toast.info('M…ôlumatlar ixrac edildi', {\n          description: 'Silinmi≈ü m…ôlumatlar Excel faylƒ± olaraq ixrac edildi.',\n          action: {\n            label: 'Y√ºkl…ô',\n            onClick: () => window.open(result.exportUrl, '_blank')\n          }\n        });\n      }\n    },\n    onError: (error: Error) => {\n      console.error('‚ùå Enhanced delete error:', error);\n      toast.error('S√ºtun silin…ôrk…ôn x…ôta ba≈ü verdi', {\n        description: error.message,\n        duration: 5000\n      });\n    }\n  });\n\n  // Create column mutation (existing)\n  const createColumn = useMutation({\n    mutationFn: async (columnData: Omit<Column, 'id'> & { id?: string }) => {\n      console.log('‚ûï Creating column with data:', columnData);\n      \n      const dbData = {\n        category_id: columnData.category_id,\n        name: columnData.name,\n        type: columnData.type,\n        is_required: columnData.is_required || false,\n        placeholder: columnData.placeholder || '',\n        help_text: columnData.help_text || '',\n        default_value: columnData.default_value || '',\n        order_index: columnData.order_index || 0,\n        validation: columnData.validation ? JSON.stringify(columnData.validation) : null,\n        options: columnData.options ? JSON.stringify(columnData.options) : null,\n        status: 'active'\n      };\n\n      const { data, error } = await supabase\n        .from('columns')\n        .insert([dbData])\n        .select()\n        .single();\n\n      if (error) {\n        console.error('‚ùå Database error creating column:', error);\n        throw new Error(error.message);\n      }\n\n      console.log('‚úÖ Column created successfully:', data);\n      return { success: true, data };\n    },\n    onSuccess: (result, variables) => {\n      queryClient.invalidateQueries({ queryKey: ['columns'] });\n      queryClient.invalidateQueries({ queryKey: ['columns', variables.category_id] });\n      toast.success('S√ºtun uƒüurla yaradƒ±ldƒ±');\n    },\n    onError: (error: Error) => {\n      console.error('‚ùå Error creating column:', error);\n      toast.error('S√ºtun yaradƒ±lark…ôn x…ôta ba≈ü verdi: ' + error.message);\n    }\n  });\n\n  // Update column mutation (existing)\n  const updateColumn = useMutation({\n    mutationFn: async (columnData: Column) => {\n      console.log('‚úèÔ∏è Updating column with data:', columnData);\n      \n      const dbData = {\n        name: columnData.name,\n        type: columnData.type,\n        is_required: columnData.is_required || false,\n        placeholder: columnData.placeholder || '',\n        help_text: columnData.help_text || '',\n        default_value: columnData.default_value || '',\n        order_index: columnData.order_index || 0,\n        validation: columnData.validation ? JSON.stringify(columnData.validation) : null,\n        options: columnData.options ? JSON.stringify(columnData.options) : null\n      };\n\n      const { data, error } = await supabase\n        .from('columns')\n        .update(dbData)\n        .eq('id', columnData.id)\n        .select()\n        .single();\n\n      if (error) {\n        console.error('‚ùå Database error updating column:', error);\n        throw new Error(error.message);\n      }\n\n      console.log('‚úÖ Column updated successfully:', data);\n      return { success: true, data };\n    },\n    onSuccess: (result, variables) => {\n      queryClient.invalidateQueries({ queryKey: ['columns'] });\n      queryClient.invalidateQueries({ queryKey: ['columns', variables.category_id] });\n      toast.success('S√ºtun uƒüurla yenil…ôndi');\n    },\n    onError: (error: Error) => {\n      console.error('‚ùå Error updating column:', error);\n      toast.error('S√ºtun yenil…ôn…ôrk…ôn x…ôta ba≈ü verdi: ' + error.message);\n    }\n  });\n\n  // Legacy delete for backward compatibility\n  const deleteColumn = useMutation({\n    mutationFn: async (columnId: string) => {\n      console.log('üóëÔ∏è Legacy delete column with ID:', columnId);\n      \n      // Use simple soft delete for legacy calls\n      const { error } = await supabase\n        .from('columns')\n        .update({ status: 'deleted' })\n        .eq('id', columnId);\n\n      if (error) {\n        console.error('‚ùå Database error deleting column:', error);\n        throw new Error(error.message);\n      }\n\n      console.log('‚úÖ Column deleted successfully (legacy)');\n      return { success: true };\n    },\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['columns'] });\n      toast.success('S√ºtun uƒüurla silindi');\n    },\n    onError: (error: Error) => {\n      console.error('‚ùå Error deleting column:', error);\n      toast.error('S√ºtun silin…ôrk…ôn x…ôta ba≈ü verdi: ' + error.message);\n    }\n  });\n\n  // Restore deleted column mutation\n  const restoreColumn = useMutation({\n    mutationFn: async (columnId: string) => {\n      console.log('üîÑ Restoring column:', columnId);\n      \n      const { data, error } = await supabase\n        .rpc('restore_deleted_column', {\n          p_column_id: columnId,\n          p_user_id: (await supabase.auth.getUser()).data.user?.id\n        });\n\n      if (error) {\n        console.error('‚ùå Error restoring column:', error);\n        throw new Error(error.message);\n      }\n\n      if (!data.success) {\n        throw new Error(data.error || 'Failed to restore column');\n      }\n\n      console.log('‚úÖ Column restored successfully:', data);\n      return data;\n    },\n    onSuccess: (result) => {\n      queryClient.invalidateQueries({ queryKey: ['columns'] });\n      queryClient.invalidateQueries({ queryKey: ['data_entries'] });\n      \n      const restoredCount = result.restored_records.data_entries + result.restored_records.sector_entries;\n      \n      toast.success(\n        `S√ºtun b…ôrpa edildi${restoredCount > 0 ? ` (${restoredCount} m…ôlumat da b…ôrpa edildi)` : ''}`,\n        {\n          duration: 5000\n        }\n      );\n    },\n    onError: (error: Error) => {\n      console.error('‚ùå Error restoring column:', error);\n      toast.error('S√ºtun b…ôrpa edil…ôrk…ôn x…ôta ba≈ü verdi: ' + error.message);\n    }\n  });\n\n  return {\n    // Enhanced deletion\n    enhancedDeleteColumn: (columnId: string, options: EnhancedDeleteOptions) => {\n      return enhancedDeleteColumn.mutateAsync({ columnId, options });\n    },\n    \n    // Restoration\n    restoreColumn: (columnId: string) => {\n      return restoreColumn.mutateAsync(columnId);\n    },\n    \n    // Legacy methods for backward compatibility\n    createColumn: (data: Omit<Column, 'id'> & { id?: string }) => {\n      return createColumn.mutateAsync(data);\n    },\n    updateColumn: (data: Column) => {\n      return updateColumn.mutateAsync(data);\n    },\n    deleteColumn: (id: string) => {\n      return deleteColumn.mutateAsync(id);\n    },\n    \n    // Loading states\n    isEnhancedDeleting: enhancedDeleteColumn.isPending,\n    isRestoring: restoreColumn.isPending,\n    isCreating: createColumn.isPending,\n    isUpdating: updateColumn.isPending,\n    isDeleting: deleteColumn.isPending\n  };\n};